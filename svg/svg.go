package svg

import (
  "os"
  "time"
  "strconv"
  "math/rand"
  "github.com/sleepydog1214/svg-generator/check"
  "github.com/sleepydog1214/svg-generator/defs"
)

var rseed = time.Now().Unix() + 123456

// RandomInt returns a random positive int between  lb <= n <= ub
func RandomInt (lb int, ub int) (r int) {
  // Make sure we get a new seed on each call
  rseed += time.Now().UnixNano()
  rseed++
  rand.Seed(rseed)

  r = (rand.Int() % ((ub + 1) - lb)) + lb
  return r
}

// randomRGB creates a random rgb(r,g,b) color
func randomRGB() (rgb string) {
  r := strconv.FormatInt(int64(RandomInt(0, 255)), 10)
  g := strconv.FormatInt(int64(RandomInt(0, 255)), 10)
  b := strconv.FormatInt(int64(RandomInt(0, 255)), 10)

  rgb = `rgb(` + r + `,` + g + `,` + b + `)`
  return
}

var xVal, yVal, wVal, hVal, sWidth int
var fill, stroke string

// shapeVals sets the random values for rectangles and ellipses
func shapeVals() () {
  xVal = RandomInt(0, defs.ShapeParams["XCorner"])
  yVal = RandomInt(0, defs.ShapeParams["YCorner"])
  wVal = RandomInt(defs.ShapeParams["LB"], defs.ShapeParams["Width"])
  hVal = RandomInt(defs.ShapeParams["LB"], defs.ShapeParams["Height"])
  sWidth = RandomInt(defs.ShapeParams["StrokeLB"], defs.ShapeParams["StrokeUB"])
  fill = randomRGB()
  stroke = randomRGB()

  if wVal > xVal {
    xVal = wVal
  }
  if hVal > yVal {
    yVal = hVal
  }
  if (wVal + xVal) > defs.ShapeParams["XCorner"] {
    xVal = xVal - ((wVal + xVal) - defs.ShapeParams["XCorner"])
  }
  if (hVal + yVal) > defs.ShapeParams["YCorner"] {
    yVal = yVal - ((hVal + yVal) - defs.ShapeParams["YCorner"])
  }
}

// PrintHeader writes the opening svg tag
func PrintHeader (fp *os.File, fname string) () {
  header := `<?xml version="1.0" encoding="UTF-8" standalone="no"?>` + "\n" +
             `<svg ` + "\n" +
             ` version="1.1"` + "\n" +
             ` width="` + defs.Params["maxWidth"] + `"` + "\n" +
             ` height="` + defs.Params["maxHeight"] + `"` + "\n" +
             ` viewBox="0 0 ` + defs.Params["maxX"] + " " + defs.Params["maxY"] + `">` + "\n" +
             `<title>TS Art Random SVG Image ` + fname + `</title>` + "\n" +
             `<desc>Randomly generated by Thomas Suchyta</desc>` + "\n"

  _, err := fp.WriteString(header)
  check.Error(err)
}

// PrintFooter writes the svg closing tag
func PrintFooter (fp *os.File) () {
  footer := `</svg>`

  _, err := fp.WriteString(footer)
  check.Error(err)
}

// Draw the base rectangle beneath all other shapes
func BaseRect (fp *os.File,) () {
    fill := randomRGB()
    stroke := randomRGB()

    rect := `<g><rect ` + "\n" +
             ` id="baseRect" ` + "\n" +
             ` x="0" y="0" ` +
             ` width="` + defs.Params["maxWidth"] + `" ` +
             ` height="` + defs.Params["maxHeight"] + `"` + "\n" +
             ` style="fill:` + fill + `;stroke:` + stroke + `;stroke-width:4;" /></g>` + "\n"

  _, err := fp.WriteString(rect)
  check.Error(err)
}

// Rectangle draw a random rectangle
func Rectangle(fp *os.File, idx int) () {
  shapeVals()

  rect := `<rect ` + "\n" +
          ` id="rect` + strconv.Itoa(idx) + `"` + "\n" +
          ` x="` + strconv.Itoa(xVal) + `"` +
          ` y="` + strconv.Itoa(yVal) + `"` +
          ` width="` + strconv.Itoa(wVal) + `"` +
          ` height="` + strconv.Itoa(hVal) + `"` + "\n" +
          ` style="fill:` + fill + `;stroke:` + stroke + `;stroke-width:` + strconv.Itoa(sWidth) + `;" />` + "\n"

  _, err := fp.WriteString(rect)
  check.Error(err)
}

// Ellipse draw a random ellipse
func Ellipse(fp *os.File, idx int) () {
    shapeVals()

    ellipse := `<ellipse ` + "\n" +
               ` id="ellipse` + strconv.Itoa(idx) + `"` + "\n" +
               ` cx="` + strconv.Itoa(xVal) + `"` +
               ` cy="` + strconv.Itoa(yVal) + `"` +
               ` rx="` + strconv.Itoa(wVal) + `"` +
               ` ry="` + strconv.Itoa(hVal) + `"` + "\n" +
               ` style="fill:` + fill + `;stroke:` + stroke + `;stroke-width:` + strconv.Itoa(sWidth) + `;" />` + "\n"

  _, err := fp.WriteString(ellipse)
  check.Error(err)
}

// Polygon draw a random Polygon
func Polygon(fp *os.File, idx int) () {
  points := RandomInt(defs.ShapeParams["PointsLB"], defs.ShapeParams["PointsUB"])
  shapeVals()

  xy := make([]string, points)
  xy[0] = strconv.Itoa(xVal) + `,` + strconv.Itoa(yVal)

  pointX := wVal / 7;
  pointY := hVal / 7;

  for i := 1; i < points; i++ {
    switch i {
      case 1:
        xVal += pointX
        yVal -= pointY
      case 2:
        xVal += pointX
        yVal += pointY
      case 3:
        xVal -= pointX
        yVal += pointY
      case 4:
        xVal -= pointX
        yVal += pointY
      case 5:
        xVal -= pointX
      case 6:
        xVal -= pointX
        yVal -= pointY
      case 7:
        xVal -= pointX
        yVal -= pointY
    }
    xy[i] = strconv.Itoa(xVal) + `,` + strconv.Itoa(yVal)
  }

  polygon := `<polygon ` + "\n" +
             ` id="polygon` + strconv.Itoa(idx) + `"` + "\n" +
             `points="`
  for i := 0; i < points; i++ {
    polygon += ` ` + xy[i]
  }
  polygon += `"` + "\n"
  polygon += ` style="fill:` + fill + `;stroke:` + stroke + `;stroke-width:` + strconv.Itoa(sWidth) + `;" />` + "\n"

  _, err := fp.WriteString(polygon)
  check.Error(err)
}

// Polyline draw a random Polyline
func Polyline(fp *os.File, idx int) () {
  points := RandomInt(defs.ShapeParams["PointsLB"], defs.ShapeParams["PointsUB"])
  shapeVals()

  xy := make([]string, points)
  xy[0] = strconv.Itoa(xVal) + `,` + strconv.Itoa(yVal)

  pointX := wVal / 7;
  pointY := hVal / 7;

  for i := 1; i < points; i++ {
    switch i {
      case 1:
        xVal += pointX
        yVal -= pointY
      case 2:
        xVal += pointX
        yVal += pointY
      case 3:
        xVal += pointX
        yVal += pointY
      case 4:
        xVal += pointX
        yVal += pointY
      case 5:
        xVal += pointX
        yVal -= pointY
      case 6:
        xVal += pointX
        yVal -= pointY
      case 7:
        xVal += pointX
        yVal += pointY
    }
    xy[i] = strconv.Itoa(xVal) + `,` + strconv.Itoa(yVal)
  }

  polyline := `<polyline ` + "\n" +
             ` id="polyline` + strconv.Itoa(idx) + `"` + "\n" +
             `points="`
  for i := 0; i < points; i++ {
    polyline += ` ` + xy[i]
  }
  polyline += `"` + "\n"
  polyline += ` style="fill:` + fill + `;stroke:` + stroke + `;stroke-width:` + strconv.Itoa(sWidth) + `;" />` + "\n"

  _, err := fp.WriteString(polyline)
  check.Error(err)
}

// StartGroup creates a new group of shapes with a set opacity
func StartGroup(fp *os.File, idx int, opacity string) () {
    group := `<g ` + "\n" +
             ` id="group` + strconv.Itoa(idx) + `"` + "\n" +
             `style="opacity:` + opacity + `">` + "\n"

  _, err := fp.WriteString(group)
  check.Error(err)
}

// EndGroup closes the group
func EndGroup(fp *os.File) () {
  group := `</g>` + "\n"

  _, err := fp.WriteString(group)
  check.Error(err)
}
